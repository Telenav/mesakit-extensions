////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Â© 2011-2021 Telenav, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package com.telenav.tdk.tools.applications.pbf.analyzer;

import com.telenav.tdk.core.application.TdkApplication;
import com.telenav.tdk.core.filesystem.File;
import com.telenav.tdk.core.kernel.commandline.*;
import com.telenav.tdk.data.formats.pbf.model.tags.*;
import com.telenav.tdk.data.formats.pbf.processing.PbfDataProcessor;
import com.telenav.tdk.data.formats.pbf.processing.filters.*;
import com.telenav.tdk.data.formats.pbf.processing.readers.SerialPbfReader;
import com.telenav.tdk.data.formats.pbf.project.TdkDataFormatsPbf;
import com.telenav.tdk.utilities.compression.codecs.huffman.character.HuffmanCharacterCodec;
import com.telenav.tdk.utilities.compression.codecs.huffman.string.HuffmanStringCodec;

import java.util.*;

import static com.telenav.tdk.data.formats.pbf.processing.PbfDataProcessor.Result.*;

/**
 * Analyzes the given PBF file argument. Huffman codec output files are generated by this application.
 *
 * @author jonathanl (shibo)
 * @see HuffmanStringCodec
 * @see HuffmanCharacterCodec
 */
public class PbfAnalyzerApplication extends TdkApplication
{
    static final ArgumentParser<File> INPUT =
            File.argumentParser("Input PBF file")
                    .required()
                    .build();

    static final SwitchParser<WayFilter> WAY_FILTER = WayFilter.wayFilter()
            .required()
            .build();

    static final SwitchParser<RelationFilter> RELATION_FILTER =
            RelationFilter.relationFilter()
                    .required()
                    .build();

    static final SwitchParser<Boolean> SHOW_WARNINGS =
            SwitchParser.booleanSwitch("show-warnings", "Show warnings for problems like bad turn restrictions")
                    .optional()
                    .defaultValue(false)
                    .build();

    static final SwitchParser<Boolean> COMPUTE_LENGTHS =
            SwitchParser.booleanSwitch("compute-lengths", "Compute lengths by highway type")
                    .optional()
                    .defaultValue(false)
                    .build();

    public static void main(final String[] arguments)
    {
        new PbfAnalyzerApplication().run(arguments);
    }

    public PbfAnalyzerApplication()
    {
        super(TdkDataFormatsPbf.get());
    }

    @Override
    protected List<ArgumentParser<?>> argumentParsers()
    {
        return List.of(INPUT);
    }

    @Override
    protected void onRun()
    {
        final var input = argument(INPUT);
        final var wayFilter = get(WAY_FILTER);
        final var relationFilter = get(RELATION_FILTER);

        final Analyzer analyzer = new Analyzer(commandLine());

        final var reader = listenTo(new SerialPbfReader(input));
        reader.process("Analyzing", new PbfDataProcessor()
        {
            @Override
            public Result onNode(final PbfNode node)
            {
                analyzer.addNode(node);
                return ACCEPTED;
            }

            @Override
            public Result onRelation(final PbfRelation relation)
            {
                if (relationFilter.accepts(relation))
                {
                    analyzer.addRelation(relation);
                    return ACCEPTED;
                }
                return FILTERED_OUT;
            }

            @Override
            public Result onWay(final PbfWay way)
            {
                if (wayFilter.accepts(way))
                {
                    analyzer.addWay(way);
                    return ACCEPTED;
                }
                return FILTERED_OUT;
            }
        });

        analyzer.report();
    }

    @Override
    protected Set<SwitchParser<?>> switchParsers()
    {
        return Set.of
                (
                        WAY_FILTER,
                        RELATION_FILTER,
                        SHOW_WARNINGS,
                        COMPUTE_LENGTHS,
                        QUIET
                );
    }
}
